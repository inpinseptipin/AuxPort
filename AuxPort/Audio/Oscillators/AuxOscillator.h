#ifndef AUXPORT_OSCILLATOR_H
#define AUXPORT_OSCILLATOR_H
#include "../../Core/Env/AuxEnv.h"
#include "../../Core/Utility/AuxUtility.h"
#include "../Filters/AuxIIR.h"
#include <random>
#include <memory>
namespace AuxPort
{
	namespace Audio
	{
		///////////////////////////////////////////////////////////////////////////////////////
		/// @brief Inheritable Class that provides common functions for all Digital Oscillators 
		///////////////////////////////////////////////////////////////////////////////////////
		class Oscillator
		{
		public:
			Oscillator() = default;
			~Oscillator() = default;
			Oscillator(const Oscillator& osc) = default;

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Use this function to set the sample rate of the oscillator [Overridable]
			///////////////////////////////////////////////////////////////////////////////////////
			virtual void setSampleRate(uint32_t sampleRate);

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Use this function to set the frequency of the oscillator [Overridable]
			///////////////////////////////////////////////////////////////////////////////////////
			virtual void setFrequency(float frequency);

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief This function generates the sample from the Oscillator [Overridable]
			///////////////////////////////////////////////////////////////////////////////////////
			virtual float process();

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Use this function to stop the Oscillator from generating samples [Overridable]
			///////////////////////////////////////////////////////////////////////////////////////
			virtual void stop();

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Checks whether the Oscillator is still generating samples [Overridable]
			///////////////////////////////////////////////////////////////////////////////////////
			virtual bool isPlaying();
		protected:
			uint32_t sampleRate = 44100;
			float frequency = 100;
			float sample = 0;
			float mod = 0;
			float inc = 0;
		};


		class TunableOscillator : public Oscillator
		{
		public:
			TunableOscillator() = default;
			~TunableOscillator() = default;
			TunableOscillator(const TunableOscillator& detunableOscillator) = default;
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief The function detunes the oscillator by semitones and cents [Overridable]
			///////////////////////////////////////////////////////////////////////////////////////
			virtual void setDetune(float semitones, float cents);
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief The function sets phase offset of a Numerically Controlled Oscillator[Overridable]
			///////////////////////////////////////////////////////////////////////////////////////
			virtual void setPhaseOffset(float phaseOffset);
		};


		namespace Sine
		{
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Sinusoidal Osciallator [Uses std::sin] 
			///////////////////////////////////////////////////////////////////////////////////////
			class Sine : public TunableOscillator
			{
			public:
				Sine() = default;
				~Sine() = default;
				Sine(const Sine& sine) = default;
				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Sinusoidal Oscillator [Uses 5th Order Sine Approximation]
			///////////////////////////////////////////////////////////////////////////////////////
			class AuxSine : public TunableOscillator
			{
			public:
				AuxSine() = default;
				~AuxSine() = default;
				AuxSine(const AuxSine& auxSine) = default;
				float process() override;
			protected:
				float x;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Sinusoidal Oscillator [Uses Parabolic Sine Approximation]
			///////////////////////////////////////////////////////////////////////////////////////
			class ParabolicSine : public Sine
			{
			public:
				ParabolicSine() = default;
				~ParabolicSine() = default;
				ParabolicSine(const ParabolicSine& parabolicSine) = default;
				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			private:
				float B = 4.0f / pi;
				float C = -4.0f / (pi * pi);
				float P = 0.225f;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Sinusoidal Oscillator [Uses Parabolic Sine Approximation]
			///////////////////////////////////////////////////////////////////////////////////////
			class BhaskaraSine : public TunableOscillator
			{
			public:
				BhaskaraSine() = default;
				~BhaskaraSine() = default;
				BhaskaraSine(const BhaskaraSine& bhaskaraSine) = default;
				float process() override;
			private:
				float modToPi = 0.0f;
			};


			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Quadratic Sine Approximation by JavidX9 (One Lone Coder)
			///////////////////////////////////////////////////////////////////////////////////////
			class JavidX9Sine : public Sine
			{
			public:
				JavidX9Sine() = default;
				~JavidX9Sine() = default;
				JavidX9Sine(const JavidX9Sine& javidX9) = default;
				float process() override;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Cubic Sine Approximation by JavidX9 (One Lone Coder)
			///////////////////////////////////////////////////////////////////////////////////////
			class JavidX9Sine2 : public JavidX9Sine
			{
			public:
				JavidX9Sine2() = default;
				~JavidX9Sine2() = default;
				JavidX9Sine2(const JavidX9Sine2& javidX9) = default;
				float process() override;
			};


			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Fast Sine Approximation using a second-order FeedForward Filters
			///////////////////////////////////////////////////////////////////////////////////////
			class FastSine : public Oscillator
			{
			public:
				FastSine() = default;
				~FastSine() = default;
				FastSine(const FastSine& fastSine) = default;
				void setFrequency(float frequency) override;
				float process() override;
				void stop() override;
			private:
				float x1 = 0;
				float x0 = 0;
				float x2 = 0;
				float a = 0;
			};
		}

		
		namespace Sawtooth
		{
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Unipolar Sawtooth [Trivial Ramp (0,1)]
			///////////////////////////////////////////////////////////////////////////////////////
			class UnipolarSawtooth : public TunableOscillator
			{
			public:
				UnipolarSawtooth() = default;
				~UnipolarSawtooth() = default;
				UnipolarSawtooth(const UnipolarSawtooth& saw) = default;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Bipolar Sawtooth [Trivial Ramp (-1,1)]
			///////////////////////////////////////////////////////////////////////////////////////
			class BipolarSawtooth : public TunableOscillator
			{
			public:
				BipolarSawtooth() = default;
				~BipolarSawtooth() = default;
				BipolarSawtooth(const BipolarSawtooth& bsaw) = default;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Antialiased Bipolar Sawtooth [Polynomial Approximation for Bandlimited Step Functions] by Vesa Välimäki
			///////////////////////////////////////////////////////////////////////////////////////
			class PBSaw : public TunableOscillator
			{
			public:
				PBSaw() = default;
				~PBSaw() = default;
				PBSaw(const PBSaw& pbs) = default;
				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Antialiased Bipolar Sawtooth [PolyBLEP with Hyperbolic Tanh] by Will Pirkle
			///////////////////////////////////////////////////////////////////////////////////////
			class PBWSaw : public PBSaw
			{
			public:
				PBWSaw() = default;
				~PBWSaw() = default;
				PBWSaw(const PBWSaw& pbs) = default;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief Sets the saturation level for the oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				void setSaturationLevel(float sat);
			protected:
				float satLevel = 1;
				float satVal = 1 / tanhf(1);
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Antialiased Biploar Sawtooth [Differentiable Parabolic Waveform] by Vesa Välimäki
			///////////////////////////////////////////////////////////////////////////////////////
			class DPWSaw : public BipolarSawtooth
			{
			public:
				DPWSaw() = default;
				~DPWSaw() = default;
				DPWSaw(const DPWSaw& pbSquare) = default;
				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief Use this function to set the frequency of the oscillator [Overridable]
				///////////////////////////////////////////////////////////////////////////////////////
				void setFrequency(float frequency) override;
				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator [Overridable]
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			protected:
				float x1 = 0.0f;
				float x = 0.0f;
				float c = 0.0f;
			};



		}
		

		namespace Square
		{
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Square Oscillator [Trival]
			///////////////////////////////////////////////////////////////////////////////////////
			class Square : public TunableOscillator
			{
			public:
				Square() = default;
				~Square() = default;
				Square(const Square& square) = default;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief Sets the pulse width for the Square Oscillator, pulseWidth = [0,100]
				///////////////////////////////////////////////////////////////////////////////////////
				void setPulseWidth(float pulseWidth = 50.0f);

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			protected:
				float pulseWidth;
			};


		}


		namespace Triangle
		{
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Triangle Oscillator [Trivial]
			///////////////////////////////////////////////////////////////////////////////////////
			class Triangle : public TunableOscillator
			{
			public:
				Triangle() = default;
				~Triangle() = default;
				Triangle(const Triangle& triangle) = default;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Antialiased Triangle Oscillator [DPW Order - 1] by Vesa Välimäki
			///////////////////////////////////////////////////////////////////////////////////////
			class DPWTriangle1 : public Sawtooth::BipolarSawtooth
			{
			public:
				DPWTriangle1() = default;
				~DPWTriangle1() = default;
				DPWTriangle1(const DPWTriangle1& dpwTriangle) = default;
				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator [Overriable]
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			};

		}

		namespace String
		{
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief String Waveguide Model [Karplus Strong]
			///////////////////////////////////////////////////////////////////////////////////////
			class KPString : public Oscillator
			{
			public:
				enum Parameters
				{
					Pick
				};
				KPString();
				~KPString() = default;
				KPString(const KPString& kpstring) = default;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function sets the sample rate
				///////////////////////////////////////////////////////////////////////////////////////
				void setSampleRate(uint32_t sampleRate) override;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function set the frequency of the oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				void setFrequency(float frequency) override;
			private:
				std::vector<float> seedBuffer;
				uint32_t r1 = 0;
				uint32_t r2 = 0;
				uint32_t seedSize = 0;
			};
		}
		

	



#if AUXPORT_EXP
		///////////////////////////////////////////////////////////////////////////////////////
		/// @brief PolyBlep Square Oscillator
		///////////////////////////////////////////////////////////////////////////////////////
		class PBSquare : public Square
		{
		public:
			PBSquare() = default;
			~PBSquare() = default;
			PBSquare(const PBSquare& pbsquare) = default;
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief This function generates the sample from the Oscillator
			///////////////////////////////////////////////////////////////////////////////////////
			float process() override;
		protected:
			float square = 0.0f;
			float modx1 = 0.0f;
			float x1 = 0.0f;
		};
#endif		

		


		

		

#if AUXPORT_EXP
		///////////////////////////////////////////////////////////////////////////////////////
		/// @brief Differentiable Parabolic Waveform Triangle (Order - 2)
		///////////////////////////////////////////////////////////////////////////////////////
		class DPWTriangle2 : public DPWSaw
		{
		public:
			DPWTriangle2() = default;
			~DPWTriangle2() = default;
			DPWTriangle2(const DPWTriangle2& dpwtriangle2) = default;
			float process() override;
		};
#endif


		namespace Noise
		{
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief WhiteNoise Oscillator [uses std::random_device]
			///////////////////////////////////////////////////////////////////////////////////////
			class WhiteNoise : public Oscillator
			{
			public:
				WhiteNoise();
				~WhiteNoise() = default;
				WhiteNoise(const WhiteNoise& wn) = default;

				///////////////////////////////////////////////////////////////////////////////////////
				/// @brief This function generates the sample from the Oscillator
				///////////////////////////////////////////////////////////////////////////////////////
				float process() override;
			private:
				std::random_device randomDevice;
				std::unique_ptr<std::mt19937> gen;
				std::unique_ptr<std::uniform_real_distribution<>> distribution;
			};

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief WhiteNoise Oscillator [uses Fast Random Float]
			///////////////////////////////////////////////////////////////////////////////////////
			class WhiteNoise2 : public Oscillator, FastRandomFloat
			{
			public:
				WhiteNoise2() = default;
				~WhiteNoise2() = default;
				WhiteNoise2(const WhiteNoise2& whitenoise2) = default;
				float process() override;
			};
#if AUXPORT_EXP
			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief WhiteNoise Oscillator [uses Gaussian White Noise]
			///////////////////////////////////////////////////////////////////////////////////////
			class PinkNoise : public Oscillator, FastRandomFloat
			{
			public:
				PinkNoise() = default;
				~PinkNoise() = default;
				PinkNoise(const PinkNoise& whiteNoise3) = default;
				float process() override;
			protected:
				float getPinkNoise();
				float b0 = 0.0f;
				float b1 = 0.0f;
				float b2 = 0.0f;
				float b3 = 0.0f;
				float b4 = 0.0f;
				float b5 = 0.0f;
				float b6 = 0.0f;
				float pink;
			};
#endif
			

		}
		

#if AUXPORT_EXP
		///////////////////////////////////////////////////////////////////////////////////////
		/// @brief ADSR Oscillator
		///////////////////////////////////////////////////////////////////////////////////////
		class ADSR
		{
		public:
			ADSR();
			~ADSR() = default;
			ADSR(const ADSR& adsr) = default;

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief This function sets the ADSR Oscillator Parameters
			///////////////////////////////////////////////////////////////////////////////////////
			void setParameters(const std::vector<float>& parameters);

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief This function sets the sample rate
			///////////////////////////////////////////////////////////////////////////////////////
			void setSampleRate(uint32_t sampleRate);

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Returns true if the oscillator is currently not in OFF State
			///////////////////////////////////////////////////////////////////////////////////////
			bool isPlaying();

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Starts the oscillator
			///////////////////////////////////////////////////////////////////////////////////////
			void start();

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief Stops the Oscillator
			///////////////////////////////////////////////////////////////////////////////////////
			void stop();

			///////////////////////////////////////////////////////////////////////////////////////
			/// @brief This function generates the sample from the Oscillator
			///////////////////////////////////////////////////////////////////////////////////////
			float process();
		private:
			enum State
			{
				Attack, Decay, Sustain, Release, AttackTime, DecayTime, SustainTime, ReleaseTime, OFF
			};
			std::vector<float> parameters;
			std::vector<float> mods;
			uint32_t sampleRate;
			float envelope;
			State state = State::OFF;
			uint32_t count = 0;
		};

#endif // AUXPORT_EXP

		

		






	}
}

#endif